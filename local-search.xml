<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Elastic Search 初体验 - 安装，运行，以及踩坑</title>
    <link href="/2020/05/26/Elastic-search-basic-md/"/>
    <url>/2020/05/26/Elastic-search-basic-md/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次邂逅-Elastic-Search-的追忆"><a href="#第一次邂逅-Elastic-Search-的追忆" class="headerlink" title="第一次邂逅 Elastic Search 的追忆"></a>第一次邂逅 Elastic Search 的追忆</h2><p>一直以来，虽然花了很多的时间在 <code>Spring</code> 系列框架上，并且一直力求自己能在明白在使用 <code>Spring</code> 框架快速开发可用的，优雅的网站的同时，还能明白底层的实现逻辑。确实却很少关注于其他方面的功能。比如搜索功能！以前在网站的查询功能上是直接将前端用户的查询请求通过 AJAX 动态向后端发送查询请求，然后再通过后端的业务逻辑直接调用DAO，将使用顺序扫描法匹配到数据从数据库直接使用 JSON 格式返回到前端展示给用户。虽然，这种做法在测试阶段还是过得去的，但是其实效率是超级低下的。因此，我在苦恼之际，问了大神朋友他是如何解决这种问题的。从大神朋友那里得到的回答是 <code>Elastic Search</code>!</p><p>说实话，孤陋寡闻的当时还是第一次听说 Elastic Search, 但是不管怎么样，还是要先去了解一下啥是 Elastic Search吧。经过一顿Google上看不懂的介绍后，大概了解了 Elastic Search 其实就是基于 <code>Lucene</code> 之上的一个全文搜索系统。至于 Lucene 是什么，简单理解就是一个强大的全文搜索的引擎。跟 Elastic Search 类似的软件其实不少，还有一个叫 <code>Solr</code> 的跟 Elastic Search 是同一个档次的造物。重要的是，<strong>Elastic Search 仅支持JSON格式</strong>, 但是 Solr 支持多种格式。至于更深的细节，我就不了解了，毕竟我现在连 ES 都还没掌握呢我的哥。</p><p>学习一个新技术吧，还是逃不出那尴尬又没有理由不会发生的事情 - 踩坑。是的，刚开始学习Elastic Search的时候我是真的刚开始就想放弃了！据我目前看来，ES的版本迭代速度跟 <code>Node.js</code> 有的一拼，并且每个版本中 <code>Deprecated</code> 的语法层出不穷。这是最大的一个学习阻碍，我目前使用的是 7.7.0 的ES，但是很多网上的教程其实都低于这个版本的，很多语法都是不兼容的。因此，我在学习的过程中也是不断地尝试，然后将当前版本可用的语法记录下来。</p><h2 id="Elastic-Search-的下载与安装"><a href="#Elastic-Search-的下载与安装" class="headerlink" title="Elastic Search 的下载与安装"></a>Elastic Search 的下载与安装</h2><p>Elastic Search 的下载很简单，直接到Elastic Search的官网下载即可。 <a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p><p>下载完成后，得到的是一个压缩包。虽然我下载是官网上的 MacOS 版本，里面提供了一个 <code>jdk.app</code> 的可执行文件，但是系统提示这是一个不兼容当前系统版本的程序，因此我也没有使用它。而是直接看向了 <code>bin/elasticsearch</code>。</p><p><img src="https://i.imgur.com/urVyTue.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="如何验证-Elastic-Search-在你电脑上活了？"><a href="#如何验证-Elastic-Search-在你电脑上活了？" class="headerlink" title="如何验证 Elastic Search 在你电脑上活了？"></a>如何验证 Elastic Search 在你电脑上活了？</h2><p>在 terminal 中直接执行该文件，等待一会后就会出现一大堆的配置信息，虽然看不懂，但是也没什么卵用。如何严重系统上的ES是否成功运行？这里有两种方法来验证。 </p><ol><li>使用 curl 指令</li></ol><div class="hljs"><pre><code class="hljs bash">curl localhost:9200</code></pre></div><p><img src="https://i.imgur.com/Zx30fUn.jpg" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>直接用浏览器打开 <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a></li></ol><p><img src="https://i.imgur.com/64enzbg.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="如何修改-Elastic-Search-的默认端口号配置？"><a href="#如何修改-Elastic-Search-的默认端口号配置？" class="headerlink" title="如何修改 Elastic Search 的默认端口号配置？"></a>如何修改 Elastic Search 的默认端口号配置？</h2><p>上面这两种方法，不论哪一种其实最终的到的结构都是一样的，只要你使用其中任何一种方法得到了类似的JSON返回，那么恭喜你！你并没有在安装和运行上踩到坑。同时你还了解到，Elastic Search的默认端口是<code>9200</code>。多么深刻的领悟啊。小黑板敲起来，ES的默认端口是 <code>9200</code>。那么这时候问题就来了，你想不想知道该去哪里改这默认的端口号呢(杠精其实都很博学的)？行吧，满足你博学的心情。</p><p><img src="https://i.imgur.com/zBFjemQ.jpg" srcset="/img/loading.gif" alt=""></p><p>看到ES目录下的 <code>config/elasticsearch.yml</code> 配置文件了吗？对，就是它，放荡不羁地打开它！然后找吧，差不多是在 <code>59 行</code> 的位置，这就是ES的默认端口号。你想改的话，就把前面的 <code>#</code> 号去掉并将后面的端口号换成你最好的数字！</p><p><img src="https://i.imgur.com/Sog1QSO.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="如何让-Elastic-Search-在活在后台？"><a href="#如何让-Elastic-Search-在活在后台？" class="headerlink" title="如何让 Elastic Search 在活在后台？"></a>如何让 Elastic Search 在活在后台？</h2><p>学习就是这么的快乐，探索就是要发现新问题！既然到这里我使用 terminal 成功的让ES快乐地运行起来了，反正它运行起来以后我也不能干什么，能不能有什么法子让它运行在后台呢？诶，我该大部分的你肯定想不到这个问题，但是开发者为你想到了。想要把ES运行在后台吧，其实也很简单只要执行:</p><div class="hljs"><pre><code class="hljs bash">/bin/elasticsearch -d</code></pre></div><p><img src="https://i.imgur.com/t3oXMIn.jpg" srcset="/img/loading.gif" alt=""></p><p>运行后，只要没有任何消息反馈给你吧，就说明运行成功了。为啥呢？正所谓没有消息就是最好的消息嘛！想验证ES是否被成功运行在后台了？老规矩，上面提到的两个方法选一个去试。到目前为止，你以为我们探索的脚步就此停歇了？兄弟，你还年轻！</p><h2 id="如何将活在后台的-Elastic-Search-杀死？"><a href="#如何将活在后台的-Elastic-Search-杀死？" class="headerlink" title="如何将活在后台的 Elastic Search 杀死？"></a>如何将活在后台的 Elastic Search 杀死？</h2><p>既然我们现在选择了让ES在后台运行，那么如何将其关闭？一开始我尝试使用 <code>Activity Moniter</code> 去关闭，但是找了一圈真的是没有发现Elastic Search的踪迹(难道是我的打开方式不对？还是ES真的藏的深)。经过一番摸索，我尝试使用 termial 继续查找ES的进程，很幸运的是，我还真的找到了并且成功关闭！老铁礼物刷起来…</p><div class="hljs"><pre><code class="hljs bash">ps -ef | grep elast</code></pre></div><p><img src="https://i.imgur.com/ZG3d9s0.jpg" srcset="/img/loading.gif" alt=""></p><p>从使用 grep 查询到的结果可以看出，图中的 <code>org.elasticsearch.bootstrap.Elasticsearch -d</code> 字样正是我们之前为自己埋下的坑 <code>/bin/elasticsearch -d</code>！这把我自己给牛逼的啊，都能自己给自己埋坑再让自己去踩啦，这把我这小心情牛逼的… 既然我们找到了进程号，接下来的事情就好办了，杀死它呗。杀完进程之后，我们顺便再查询一下。诶，世界真美丽。</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 57587</code></pre></div><p><img src="https://i.imgur.com/noFBeTn.jpg" srcset="/img/loading.gif" alt=""></p><p>到此，Elastic Search 算是彻底被放在 terminal 中开来关去了。为今天能熟练开关ES的自己一个么么哒。探索是为了发现，学习是为了踩坑，我还是那个放荡不羁的少年。</p>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elastic Search</tag>
      
      <tag>踩坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 反射机制</title>
    <link href="/2020/05/24/java_reflect/"/>
    <url>/2020/05/24/java_reflect/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-反射机制背景"><a href="#Java-反射机制背景" class="headerlink" title="Java 反射机制背景"></a>Java 反射机制背景</h2><p>在Java运行的环境中，对于任意一个类，能否知道这个类有哪些属性和方法？<br>或者说，对任意一个对象，能否调用它的任意一个方法？</p><p>这种动态获取类的信息以及动态调用对象的方法的功能来自于Java的语法放射机制</p><ul><li>Java的语言反射机制主要有4个功能 <ol><li>在运行时判断任意一个对象属性所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ol></li></ul><p>Reflection 机制是Java被视为准动态语言的一个关键性质。<br>动态语言: 指程序运行时，允许改变程序结构或变量类型的编程语言。</p><p>这个机制允许程序在运行时通过Relection APIs获取任何一个已知名称的class的内部信息</p><ul><li>包括:<ol><li>修饰符 modifiers (public, private, static 等等)</li><li>superclass (Object 等等)</li><li>interfaces (Serializable)</li><li>Fields</li><li>Methods （不包括方法的具体定义）</li></ol></li></ul><p>通过反射，我们可以打破类的包装机制。</p><p>Java程序可以加载一个运行时才得知名称的class，获悉其完整构造，并生成其对象实体，对其的字段赋值，或调用它的方法。这种透析class的能力被称为 <code>Introspection</code> 内省，内观。</p><h2 id="Reflection-常用API"><a href="#Reflection-常用API" class="headerlink" title="Reflection 常用API"></a>Reflection 常用API</h2><p>Java的反射机制包位于 java.lang.reflect包中</p><ol><li>Class类: 代表一个类<ol><li>forName(String className)</li><li>getComponentType()</li><li>getConstructor(Class&lt;?&gt;… parameterTypes)</li><li>getConstructors()</li><li>getInterfaces()</li><li>getField(String name)</li><li>getFields()</li><li>getMethod(String name, Class&lt;?&gt;… parameterTypes)</li><li>getMethods()</li><li>getName()</li><li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</li><li>getDeclaredConstructors()</li><li>getDeclaredField(String name)</li><li>getDeclaredFields()</li><li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</li><li>getDeclaredMethods()</li><li>newInstance()</li></ol></li><li>Field类: 代表类的成员变量（属性，字段）<ol><li>get(Object obj)</li><li>getName()</li><li>getType()</li><li>set(Object obj, Object value)</li></ol></li><li>Method类: 代表类的方法<ol><li>getName()</li><li>getReturnType()</li><li>invoke(Object obj, Object… args)</li></ol></li><li>Constructor类: 代表类的构造函数<ol><li>getName()</li><li>newInstance(Object… initargs)</li></ol></li><li>Array类: 提供了动态创建数组，以及访问数组的元素的静态方法<ol><li>newInstance(Class&lt;?&gt; componentType, int… dimensions)</li><li>newInstance(Class&lt;?&gt; componentType, int length)</li><li>get(Object array, int index)</li><li>set(Object array, int index, Object value)</li></ol></li><li>AccessibleObject<ol><li>isAccessible()</li><li>setAccessible(boolean flag)</li></ol></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.reflection;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionTest</span> </span>&#123;    <span class="hljs-comment">//成员变量</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">// 构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionTest</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"无参构造函数"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionTest</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ReflectionTest</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-comment">// getters</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> age; &#125;    <span class="hljs-comment">// 成员方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">return</span> a+b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String word)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello "</span> + word;    &#125;&#125;</code></pre></div><h2 id="案例一-使用反射机制获取对象的实例"><a href="#案例一-使用反射机制获取对象的实例" class="headerlink" title="案例一: 使用反射机制获取对象的实例"></a>案例一: 使用反射机制获取对象的实例</h2><div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.reflection.ReflectionTest"</span>);Object obj = clazz.getDeclaredConstructor().newInstance();System.out.println(obj <span class="hljs-keyword">instanceof</span> ReflectionTest); <span class="hljs-comment">//true</span></code></pre></div><h2 id="案例二-使用反射机制获取对象的成员属性"><a href="#案例二-使用反射机制获取对象的成员属性" class="headerlink" title="案例二: 使用反射机制获取对象的成员属性"></a>案例二: 使用反射机制获取对象的成员属性</h2><div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; clazz = ReflectionTest<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;ReflectionTest obj = (ReflectionTest) clazz.getDeclaredConstructor().newInstance();<span class="hljs-comment">// age</span>Field age = clazz.getDeclaredField(<span class="hljs-string">"age"</span>);age.set(obj, <span class="hljs-number">20</span>);System.out.println(obj.getAge());</code></pre></div><h2 id="案例三-使用反射机制获取对象的成员方法"><a href="#案例三-使用反射机制获取对象的成员方法" class="headerlink" title="案例三: 使用反射机制获取对象的成员方法"></a>案例三: 使用反射机制获取对象的成员方法</h2><div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; clazz = <span class="hljs-keyword">new</span> ReflectionTest().getClass();Object obj = clazz.getDeclaredConstructor().newInstance();Method method = clazz.getDeclaredMethod(<span class="hljs-string">"add"</span>, <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>&#125;)</span>;<span class="hljs-keyword">int</span> res = (<span class="hljs-keyword">int</span>) method.invoke(obj, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-number">10</span>,<span class="hljs-number">5</span>&#125;);System.out.println(res); <span class="hljs-comment">//15</span></code></pre></div><h2 id="案例四-使用反射机制获取对象的构造函数-无参-amp-带参"><a href="#案例四-使用反射机制获取对象的构造函数-无参-amp-带参" class="headerlink" title="案例四: 使用反射机制获取对象的构造函数(无参&amp;带参)"></a>案例四: 使用反射机制获取对象的构造函数(无参&amp;带参)</h2><div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; clazz = ReflectionTest<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<span class="hljs-comment">// 获取无参构造函数</span>Object c = clazz.getConstructor().newInstance();<span class="hljs-comment">// 获取带参构造函数</span>Constructor cons = clazz.getDeclaredConstructor(<span class="hljs-keyword">new</span> Class[]&#123;String<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>;ReflectionTest obj = (ReflectionTest) cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">"1234567890"</span>&#125;);System.out.println(obj.getName());</code></pre></div><h2 id="案例五-使用放射机制获取对象的私有成员"><a href="#案例五-使用放射机制获取对象的私有成员" class="headerlink" title="案例五: 使用放射机制获取对象的私有成员"></a>案例五: 使用放射机制获取对象的私有成员</h2><div class="hljs"><pre><code class="hljs java">Class&lt;?&gt; clazz = ReflectionTest<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;ReflectionTest obj = (ReflectionTest) clazz.getConstructor().newInstance();<span class="hljs-comment">// 设置私有属性</span>Field field = clazz.getDeclaredField(<span class="hljs-string">"name"</span>);field.setAccessible(<span class="hljs-keyword">true</span>);field.set(obj, <span class="hljs-string">"097654321"</span>);System.out.println(<span class="hljs-string">"私有属性 name: "</span> + obj.getName());<span class="hljs-comment">// 设置私有方法</span>Method method = clazz.getDeclaredMethod(<span class="hljs-string">"sayHello"</span>, <span class="hljs-keyword">new</span> Class[]&#123;String<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>;method.setAccessible(<span class="hljs-keyword">true</span>);String res = (String) method.invoke(obj, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">"World"</span>&#125;);System.out.println(res);<span class="hljs-comment">// 设置私有构造函数</span>Constructor c = clazz.getDeclaredConstructor(<span class="hljs-keyword">new</span> Class[]&#123;String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>&#125;)</span>;c.setAccessible(<span class="hljs-keyword">true</span>);ReflectionTest cons = (ReflectionTest) c.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">"qwertyuiop"</span>, <span class="hljs-number">90</span>&#125;);System.out.println(cons.getName());System.out.println(cons.getAge());</code></pre></div><h2 id="案例六-使用getter-amp-setter-实现对象浅拷贝"><a href="#案例六-使用getter-amp-setter-实现对象浅拷贝" class="headerlink" title="案例六: 使用getter &amp; setter 实现对象浅拷贝"></a>案例六: 使用getter &amp; setter 实现对象浅拷贝</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dump</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> Order order;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> order;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrder</span><span class="hljs-params">(Order order)</span> </span>&#123;        <span class="hljs-keyword">this</span>.order = order;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;    String orderId;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Order</span><span class="hljs-params">(String orderId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.orderId = orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderId</span><span class="hljs-params">(String orderId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.orderId = orderId;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">copy</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Class&lt;?&gt; clazz = object.getClass();        Object obj = clazz.getDeclaredConstructor(<span class="hljs-keyword">new</span> Class[]&#123;&#125;).newInstance(<span class="hljs-keyword">new</span> Object[]&#123;&#125;);        <span class="hljs-comment">// 获取所有的成员属性</span>        Field[] fields = clazz.getDeclaredFields();        <span class="hljs-keyword">for</span>(Field f: fields)&#123;            <span class="hljs-comment">// 获取成员属性名</span>            String AttrName = f.getName();            <span class="hljs-comment">// 将属性名首个小写字母转化为大写字母</span>            <span class="hljs-keyword">if</span>(AttrName.charAt(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">96</span> &amp;&amp; AttrName.charAt(<span class="hljs-number">0</span>) &lt; <span class="hljs-number">123</span>)&#123;                <span class="hljs-keyword">char</span>[] chars= AttrName.toCharArray();                chars[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">char</span>)(((<span class="hljs-keyword">int</span>)chars[<span class="hljs-number">0</span>]) - <span class="hljs-number">32</span>);                AttrName = String.valueOf(chars);            &#125;            <span class="hljs-comment">// 获取所有的setter &amp; getter</span>            Method setter = clazz.getDeclaredMethod((<span class="hljs-string">"set"</span> + AttrName), <span class="hljs-keyword">new</span> Class[]&#123;f.getType()&#125;);            Method getter = clazz.getDeclaredMethod((<span class="hljs-string">"get"</span> + AttrName), <span class="hljs-keyword">new</span> Class[]&#123;&#125;);            <span class="hljs-comment">// 将对象的成员属性赋值到目标对象中</span>            Object value = getter.invoke(object, <span class="hljs-keyword">new</span> Object[]&#123;&#125;);            setter.invoke(obj, value);        &#125;        <span class="hljs-keyword">return</span> obj;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Dump dump = <span class="hljs-keyword">new</span> Dump();        dump.setName(<span class="hljs-string">"Dump"</span>);        dump.setAge(<span class="hljs-number">30</span>);        dump.setOrder(<span class="hljs-keyword">new</span> Order(<span class="hljs-string">"1234567890"</span>));        Dump copiedDump = (Dump) Main.copy(dump);        System.out.println(dump.getOrder());        System.out.println(copiedDump.getOrder());        System.out.println(<span class="hljs-string">"原先的象: "</span> + dump);        System.out.println(<span class="hljs-string">"复制的对象: "</span> + copiedDump);    &#125;&#125;</code></pre></div><h2 id="案例七-使用放射机制创建一维数组"><a href="#案例七-使用放射机制创建一维数组" class="headerlink" title="案例七: 使用放射机制创建一维数组"></a>案例七: 使用放射机制创建一维数组</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Array;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置 componentType 组件类型</span>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"java.lang.String"</span>);        <span class="hljs-comment">// 使用反射创建一个数组实例 newInstance(Class&lt;?&gt; componentType, int length)</span>        Object array = Array.newInstance(clazz, <span class="hljs-number">3</span>);        <span class="hljs-comment">// 为数组中下标为1的元素设置数据</span>        Array.set(array, <span class="hljs-number">1</span>, <span class="hljs-string">"Hello World"</span>);        <span class="hljs-comment">// 获取数据</span>        String res = (String) Array.get(array, <span class="hljs-number">1</span>);        System.out.println(res);        <span class="hljs-comment">// 迭代数组中的元素</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;((String[]) array).length ;i++)&#123;            System.out.println(((String[]) array)[i]);        &#125;    &#125;&#125;</code></pre></div><h2 id="案例八-使用放射机制创建多维数组"><a href="#案例八-使用放射机制创建多维数组" class="headerlink" title="案例八: 使用放射机制创建多维数组"></a>案例八: 使用放射机制创建多维数组</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Array;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置维度&amp;长度</span>        <span class="hljs-comment">// 维度一：length=2;</span>        <span class="hljs-comment">// 维度二：length=3;</span>        <span class="hljs-keyword">int</span>[] dims = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;        <span class="hljs-comment">// 设置 componentType</span>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"java.lang.String"</span>);        <span class="hljs-comment">// 创建多维数组实例 newInstance(Class&lt;?&gt; componentType, int... dimensions)</span>        Object array = Array.newInstance(clazz, dims);        <span class="hljs-comment">// 查看 componentType</span>        Class&lt;?&gt; classType = array.getClass().getComponentType();        System.out.println(classType);        <span class="hljs-comment">// 获取第二维度</span>        Object obj = Array.get(array, <span class="hljs-number">1</span>);        <span class="hljs-comment">// 为第二维度设置数据</span>        Array.set(obj, <span class="hljs-number">2</span>, <span class="hljs-string">"Hello World"</span>);        <span class="hljs-comment">// 强制转换数组结果</span>        String[][] arr = (String[][]) array;        System.out.println(<span class="hljs-string">"第一维度长度: "</span> + arr.length);        System.out.println(<span class="hljs-string">"第二维度长度: "</span> + arr[<span class="hljs-number">0</span>].length);        <span class="hljs-comment">// 迭代数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length ;i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;arr[i].length ;j++)&#123;                System.out.print(arr[i][j] + <span class="hljs-string">" "</span>);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>reflect</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
